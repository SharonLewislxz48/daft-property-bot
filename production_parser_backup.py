#!/usr/bin/env python3
"""
–ì–æ—Ç–æ–≤—ã–π –∫ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É –ø–∞—Ä—Å–µ—Ä daft.ie —Å JSON –ø–æ–¥—Ö–æ–¥–æ–º
"""

import asyncio
import re
import json
import aiohttp
from typing import List, Dict, Any, Optional
from datetime import datetime
import logging

class ProductionDaftParser:
    """
    –ü—Ä–æ–¥–∞–∫—à–µ–Ω-–≥–æ—Ç–æ–≤—ã–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è daft.ie —Å JSON –ø–æ–¥—Ö–æ–¥–æ–º
    """
    
    def __init__(self):
        self.base_url = "https://www.daft.ie"
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    def extract_json_data(self, html_content: str) -> List[Dict[str, Any]]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç JSON –¥–∞–Ω–Ω—ã–µ –∏–∑ React –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
        try:
            # –ü–æ–∏—Å–∫ script —ç–ª–µ–º–µ–Ω—Ç–∞ —Å __NEXT_DATA__
            pattern = r'<script id="__NEXT_DATA__"[^>]*>([^<]+)</script>'
            match = re.search(pattern, html_content)
            
            if not match:
                logging.error("__NEXT_DATA__ script –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return []
            
            json_str = match.group(1)
            data = json.loads(json_str)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º listings –∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
            listings = data.get('props', {}).get('pageProps', {}).get('listings', [])
            logging.info(f"–ù–∞–π–¥–µ–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –≤ JSON: {len(listings)}")
            
            # –ü–∞—Ä—Å–∏–º –∫–∞–∂–¥–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
            properties = []
            for item in listings:
                listing = item.get('listing', {})
                if not listing:
                    continue
                    
                property_data = self.parse_listing(listing)
                if property_data:
                    properties.append(property_data)
            
            return properties
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")
            return []
    
    def parse_listing(self, listing: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """–ü–∞—Ä—Å–∏—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –∏–∑ JSON"""
        try:
            # –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            property_id = str(listing.get('id', ''))
            title = listing.get('title', '')
            price = listing.get('price', '')
            bedrooms_str = listing.get('numBedrooms', '')
            property_type = listing.get('propertyType', '')
            
            # URL –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è
            seo_path = listing.get('seoFriendlyPath', '')
            url = f"https://www.daft.ie{seo_path}" if seo_path else ""
            
            # –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ (–∏–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞)
            location_parts = title.split(',')
            if len(location_parts) >= 2:
                location = ', '.join(location_parts[-2:]).strip()
            else:
                location = title
            
            # –î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏
            publish_date = listing.get('publishDate')
            date_published = None
            if publish_date:
                try:
                    date_published = datetime.fromtimestamp(publish_date / 1000).strftime('%Y-%m-%d')
                except:
                    pass
            
            # –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            media = listing.get('media', {})
            images = media.get('images', [])
            image_urls = []
            for img in images[:3]:  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 3 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                if 'size720x480' in img:
                    image_urls.append(img['size720x480'])
            
            # –ü—Ä–æ–¥–∞–≤–µ—Ü
            seller = listing.get('seller', {})
            agent_name = seller.get('name', '')
            phone = seller.get('phone', '')
            
            # –≠–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            ber = listing.get('ber', {})
            energy_rating = ber.get('rating', '') if ber else ''
            
            # –ü–∞—Ä—Å–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω
            bedrooms = self._parse_bedrooms_from_json(bedrooms_str)
            
            # –ü–∞—Ä—Å–∏–º —Ü–µ–Ω—É
            monthly_rent = self._parse_price(price)
            
            property_data = {
                'id': property_id,
                'title': title,
                'url': url,
                'price': monthly_rent,
                'bedrooms': bedrooms,
                'property_type': property_type,
                'location': location,
                'date_published': date_published,
                'images': image_urls,
                'agent_name': agent_name,
                'phone': phone,
                'energy_rating': energy_rating
            }
            
            logging.debug(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ: {title} - {price}")
            return property_data
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–∑ JSON: {e}")
            return None
    
    def _parse_bedrooms_from_json(self, bedrooms_str: str) -> int:
        """–ü–∞—Ä—Å–∏—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω –∏–∑ JSON —Å—Ç—Ä–æ–∫–∏"""
        try:
            # –ò—â–µ–º —á–∏—Å–ª–∞ –≤ —Å—Ç—Ä–æ–∫–µ —Ç–∏–ø–∞ "1, 2, 3 & 5 bed" –∏–ª–∏ "3 Bed"
            numbers = re.findall(r'\d+', bedrooms_str)
            if numbers:
                # –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω
                return int(numbers[0])
        except (ValueError, AttributeError):
            pass
        return 1  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
    def _parse_price(self, price_str: str) -> int:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ü–µ–Ω—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏"""
        try:
            # –£–±–∏—Ä–∞–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä
            price_clean = re.sub(r'[^\d]', '', price_str)
            if price_clean:
                return int(price_clean)
        except (ValueError, AttributeError):
            pass
        return 0
    
    async def search_properties(
        self, 
        min_bedrooms: int = 3, 
        max_price: int = 2500, 
        location: str = "dublin-city", 
        limit: int = 20,
        max_pages: int = 3
    ) -> List[Dict[str, Any]]:
        """
        –ò—â–µ—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å –Ω–∞ daft.ie —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        
        Args:
            min_bedrooms: –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω
            max_price: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω–∞ –≤ –µ–≤—Ä–æ
            location: –õ–æ–∫–∞—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ (dublin-city, cork, etc.)
            limit: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            max_pages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
            
        Returns:
            –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π —Å –¥–∞–Ω–Ω—ã–º–∏ –æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏
        """
        logging.info(f"üîç –ü–û–ò–°–ö: {min_bedrooms}+ —Å–ø–∞–ª–µ–Ω, –¥–æ ‚Ç¨{max_price}, {location} (–¥–æ {max_pages} —Å—Ç—Ä–∞–Ω–∏—Ü)")
        
        properties = []
        seen_ids = set()
        
        # –°–æ–∑–¥–∞–µ–º HTTP session
        if not self.session:
            self.session = aiohttp.ClientSession()
        
        for page in range(1, max_pages + 1):
            try:
                # –§–æ—Ä–º–∏—Ä—É–µ–º URL
                url = self._build_search_url(min_bedrooms, max_price, location, page)
                logging.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page}: {url}")
                
                # –î–µ–ª–∞–µ–º HTTP –∑–∞–ø—Ä–æ—Å —Å —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
                headers = {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache',
                    'Sec-Ch-Ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
                    'Sec-Ch-Ua-Mobile': '?0',
                    'Sec-Ch-Ua-Platform': '"Linux"',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                    'Sec-Fetch-User': '?1',
                    'Upgrade-Insecure-Requests': '1'
                }
                
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                await asyncio.sleep(1)
                
                async with self.session.get(url, headers=headers) as response:
                    if response.status != 200:
                        logging.error(f"HTTP –æ—à–∏–±–∫–∞ {response.status} –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page}")
                        continue
                    
                    html_content = await response.text()
                    logging.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(html_content)} —Å–∏–º–≤–æ–ª–æ–≤ HTML –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page}")
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏ –ø–∞—Ä—Å–∏–º JSON –¥–∞–Ω–Ω—ã–µ
                    page_properties = self.extract_json_data(html_content)
                    
                    if not page_properties:
                        logging.info(f"–ù–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–π –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page}, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é")
                        break
                    
                    # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è
                    new_properties = []
                    for prop in page_properties:
                        if (prop and prop['id'] not in seen_ids and 
                            self._matches_criteria(prop, min_bedrooms, max_price)):
                            seen_ids.add(prop['id'])
                            new_properties.append(prop)
                    
                    properties.extend(new_properties)
                    logging.info(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {len(new_properties)} –Ω–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç
                    if len(properties) >= limit:
                        properties = properties[:limit]
                        break
                    
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {page}: {e}")
                continue
        
        logging.info(f"JSON –ø–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω. –ù–∞–π–¥–µ–Ω–æ {len(properties)} –æ–±—ä—è–≤–ª–µ–Ω–∏–π")
        return properties
    
    def _build_search_url(self, min_bedrooms: int, max_price: int, location: str, page: int = 1) -> str:
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ URL –¥–ª—è –ø–æ–∏—Å–∫–∞"""
        base_url = f"{self.base_url}/property-for-rent/{location}/houses"
        
        params = [
            f"rentalPrice_to={max_price}",
            f"numBeds_from={min_bedrooms}"
        ]
        
        if page > 1:
            params.append(f"page={page}")
        
        return f"{base_url}?{'&'.join(params)}"
    
    def _matches_criteria(self, property_data: Dict[str, Any], min_bedrooms: int, max_price: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∫—Ä–∏—Ç–µ—Ä–∏—è–º –ø–æ–∏—Å–∫–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ø–∞–ª–µ–Ω
            bedrooms = property_data.get('bedrooms', 0)
            if bedrooms < min_bedrooms:
                return False
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–Ω—ã
            price = property_data.get('price', 0)
            if price > max_price:
                return False
            
            return True
        except Exception:
            return False

# –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
class DaftParser:
    """–ê–ª–∏–∞—Å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
    
    def __init__(self):
        self._parser = ProductionDaftParser()
    
    async def search_properties(self, **kwargs):
        async with self._parser:
            return await self._parser.search_properties(**kwargs)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
async def main():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä—Å–µ—Ä–∞"""
    async with ProductionDaftParser() as parser:
        properties = await parser.search_properties(
            min_bedrooms=3,
            max_price=2500,
            location='dublin-city',
            limit=10,
            max_pages=2
        )
        
        print(f"\n‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(properties)} –æ–±—ä—è–≤–ª–µ–Ω–∏–π:")
        for i, prop in enumerate(properties, 1):
            print(f"{i}. {prop['title']} - ‚Ç¨{prop['price']}/–º–µ—Å ({prop['bedrooms']} —Å–ø–∞–ª–µ–Ω)")
            print(f"   {prop['url']}")

if __name__ == "__main__":
    import logging
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
                    viewport={'width': 1920, 'height': 1080},
                    extra_http_headers={
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'Accept-Language': 'en-US,en;q=0.5',
                        'Accept-Encoding': 'gzip, deflate',
                        'Connection': 'keep-alive',
                    }
                )
                
                page = await context.new_page()
                
                all_property_urls = []
                results = []
                
                # –ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–∞–Ω–∏—Ü
                for page_num in range(max_pages):
                    if page_num == 0:
                        # –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ page
                        search_url = f"{self.base_url}/property-for-rent/{location}/houses?rentalPrice_to={max_price}&numBeds_from={min_bedrooms}"
                    else:
                        # –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º page
                        search_url = f"{self.base_url}/property-for-rent/{location}/houses?rentalPrice_to={max_price}&numBeds_from={min_bedrooms}&page={page_num + 1}"
                    
                    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–∏—Å–∫–∞
                    print(f"üìÑ –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É {page_num + 1}/{max_pages}: {search_url}")
                    await page.goto(search_url, wait_until='networkidle', timeout=30000)
                    await page.wait_for_timeout(3000)
                    
                    if page_num == 0:
                        # –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–æ–ª—å–∫–æ –Ω–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
                        total_count = await self._get_results_count(page)
                        print(f"üìä –î–æ—Å—Ç—É–ø–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {total_count}")
                    
                    # –°–æ–±–∏—Ä–∞–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Å —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                    page_property_urls = await self._collect_property_urls(page)
                    print(f"üîó –ù–∞–π–¥–µ–Ω–æ —Å—Å—ã–ª–æ–∫ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page_num + 1}: {len(page_property_urls)}")
                    
                    if not page_property_urls:
                        print(f"‚ùå –ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page_num + 1} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∏—Å–∫")
                        break
                    
                    all_property_urls.extend(page_property_urls)
                    
                    # –ï—Å–ª–∏ —É–∂–µ —Å–æ–±—Ä–∞–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Å—ã–ª–æ–∫, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
                    if len(all_property_urls) >= limit:
                        break
                
                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                urls_to_process = all_property_urls[:limit]
                print(f"üìù –í—Å–µ–≥–æ —Å–æ–±—Ä–∞–Ω–æ —Å—Å—ã–ª–æ–∫: {len(all_property_urls)}, –±—É–¥–µ–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å: {len(urls_to_process)} –æ–±—ä—è–≤–ª–µ–Ω–∏–π")
                
                # –ü–∞—Ä—Å–∏–º –∫–∞–∂–¥–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
                filtered_out = 0
                
                for i, url in enumerate(urls_to_process, 1):
                    print(f"  {i}/{len(urls_to_process)}: {self._get_property_name(url)}")
                    
                    property_data = await self._parse_property(page, url)
                    if property_data:
                        # –í–ê–ñ–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º
                        if self._validate_property(property_data, min_bedrooms, max_price):
                            results.append(property_data)
                            self._print_property_summary(property_data)
                        else:
                            filtered_out += 1
                            print(f"    üö´ –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ: {property_data.get('bedrooms', '?')} —Å–ø–∞–ª–µ–Ω, ‚Ç¨{property_data.get('price', '?')}")
                    else:
                        print("    ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
                
                print(f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç: {len(results)} –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö, {filtered_out} –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã—Ö")
                
                # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                unique_results = self._remove_duplicates(results)
                
                print(f"‚úÖ –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {len(unique_results)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π")
                return unique_results
                
            except asyncio.CancelledError:
                print("üõë –ü–∞—Ä—Å–∏–Ω–≥ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω")
                raise  # –ü–µ—Ä–µ–ø–æ–¥–Ω–∏–º–∞–µ–º CancelledError –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
                
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
                return []
                
            finally:
                # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                try:
                    if page:
                        await page.close()
                except:
                    pass
                    
                try:
                    if context:
                        await context.close()
                except:
                    pass
                    
                try:
                    if browser:
                        await browser.close()
                except:
                    pass
    
    async def _get_results_count(self, page) -> int:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞"""
        try:
            h1_element = await page.wait_for_selector('h1', timeout=5000)
            h1_text = await h1_element.text_content()
            count_match = re.search(r'(\d+)', h1_text or '')
            return int(count_match.group(1)) if count_match else 0
        except:
            return 0
    
    async def _collect_property_urls(self, page) -> List[str]:
        """–°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"""
        try:
            property_links = await page.query_selector_all('a[href*="/for-rent/"]')
            
            unique_urls = set()
            for link in property_links:
                href = await link.get_attribute('href')
                if href and '/for-rent/' in href and href not in unique_urls:
                    if href.startswith('/'):
                        href = self.base_url + href
                    unique_urls.add(href)
            
            return list(unique_urls)
        except:
            return []
    
    def _get_property_name(self, url: str) -> str:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫—Ä–∞—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–∑ URL"""
        try:
            return url.split('/')[-2][:40] + "..." if len(url.split('/')[-2]) > 40 else url.split('/')[-2]
        except:
            return "unknown"
    
    async def _parse_property(self, page, url: str) -> Optional[Dict[str, Any]]:
        """–ü–∞—Ä—Å–∏—Ç –æ—Ç–¥–µ–ª—å–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        try:
            await page.goto(url, wait_until='domcontentloaded', timeout=15000)
            await page.wait_for_timeout(2000)
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            page_content = await page.content()
            
            property_data = {
                'url': url,
                'title': None,
                'price': None,
                'bedrooms': None,
                'property_type': None,
                'location': None,
                'description': None,
                'parsed_at': datetime.datetime.now().isoformat()
            }
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—à–∞–≥–æ–≤–æ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
            try:
                property_data['title'] = await self._extract_title(page)
            except Exception as e:
                print(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–∞: {e}")
            
            try:
                property_data['price'] = await self._extract_price(page, page_content)
            except Exception as e:
                print(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ü–µ–Ω—ã: {e}")
            
            try:
                property_data['bedrooms'] = await self._extract_bedrooms(page, page_content)
            except Exception as e:
                print(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å–ø–∞–ª–µ–Ω: {e}")
            
            try:
                property_data['property_type'] = self._extract_property_type(page_content)
                property_data['description'] = self._extract_description(page_content)
            except Exception as e:
                print(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–æ–ø. –¥–∞–Ω–Ω—ã—Ö: {e}")
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –ª–æ–∫–∞—Ü–∏—é –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞
            if property_data['title']:
                property_data['location'] = self._extract_location_from_title(property_data['title'])
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            if property_data['title'] or property_data['price']:
                return property_data
            
            return None
            
        except Exception as e:
            print(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞: {str(e)[:50]}...")
            return None
    
    async def _extract_title(self, page) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        try:
            title_element = await page.query_selector('h1')
            if title_element:
                title_text = await title_element.text_content()
                return title_text.strip() if title_text else None
        except:
            pass
        return None
    
    async def _extract_price(self, page, page_content: str) -> Optional[int]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ü–µ–Ω—É –∏–∑ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ"""
        # –ü—Ä–æ–±—É–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
        price_selectors = [
            '[data-testid="price"]',
            '.TitleBlock_price',
            'span:has-text("‚Ç¨")',
            '.price'
        ]
        
        for selector in price_selectors:
            try:
                price_element = await page.query_selector(selector)
                if price_element:
                    price_text = await price_element.text_content()
                    price_match = re.search(r'‚Ç¨([\d,]+)', price_text or '')
                    if price_match:
                        return int(price_match.group(1).replace(',', ''))
            except:
                continue
        
        # –ò—â–µ–º –≤ JSON –¥–∞–Ω–Ω—ã—Ö
        try:
            json_match = re.search(r'"price":\s*(\d+)', page_content)
            if json_match:
                return int(json_match.group(1))
        except:
            pass
        
        return None
    
    def _remove_duplicates(self, properties: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        –£–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã –æ–±—ä—è–≤–ª–µ–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ URL, –∞–¥—Ä–µ—Å–∞ –∏ —Ü–µ–Ω—ã
        
        Args:
            properties: –°–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π
            
        Returns:
            –°–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
        """
        seen_properties = set()
        unique_properties = []
        duplicates_count = 0
        
        for prop in properties:
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á –Ω–∞ –æ—Å–Ω–æ–≤–µ URL (–æ—Å–Ω–æ–≤–Ω–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä)
            url = prop.get('url', '')
            if url:
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º URL (—É–±–∏—Ä–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞)
                clean_url = url.split('?')[0].split('#')[0]
                
                if clean_url in seen_properties:
                    duplicates_count += 1
                    continue
                
                seen_properties.add(clean_url)
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–µ–º –∫–ª—é—á –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏–π –±–µ–∑ URL
            # –∏–ª–∏ –¥–ª—è –¥–≤–æ–π–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
            title = prop.get('title', '').lower().strip()
            price = prop.get('price', 0)
            bedrooms = prop.get('bedrooms', 0)
            location = prop.get('location', '').lower().strip()
            
            # –°–æ–∑–¥–∞–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á
            char_key = f"{title}_{location}_{price}_{bedrooms}"
            
            if char_key in seen_properties:
                duplicates_count += 1
                continue
            
            seen_properties.add(char_key)
            unique_properties.append(prop)
        
        if duplicates_count > 0:
            print(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤: {duplicates_count}")
            print(f"üìä –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {len(unique_properties)}")
        
        return unique_properties

    def _validate_property(self, property_data: Dict[str, Any], min_bedrooms: int, max_price: int) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º –∏ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö"""
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        if not property_data.get('title') or not property_data.get('price'):
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–Ω—É
        price = property_data.get('price')
        if not price or price <= 0 or price > max_price:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω
        bedrooms = property_data.get('bedrooms')
        if bedrooms is None or bedrooms < min_bedrooms:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–ø–∞–ª–µ–Ω (–Ω–µ –±–æ–ª—å—à–µ 10)
        if bedrooms > 10:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã (–Ω–µ –º–µ–Ω—å—à–µ ‚Ç¨500 –≤ –º–µ—Å—è—Ü)
        if price < 500:
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ —Ä–µ–∫–ª–∞–º–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
        title = property_data.get('title', '').lower()
        if any(keyword in title for keyword in ['advertisement', 'sponsored', 'promoted']):
            return False
        
        return True

    async def _extract_bedrooms(self, page, page_content: str) -> Optional[int]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–∞–ª–µ–Ω —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π"""
        
        # –°–ø–∏—Å–æ–∫ –¥–ª—è —Å–±–æ—Ä–∞ –≤—Å–µ—Ö –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        found_bedrooms = []
        
        # 1. –ò—â–µ–º –≤ JSON –¥–∞–Ω–Ω—ã—Ö
        try:
            # Structured data
            json_match = re.search(r'"numBedrooms":\s*"?(\d+)"?', page_content)
            if json_match:
                bedrooms = int(json_match.group(1))
                if 0 <= bedrooms <= 10:  # –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
                    found_bedrooms.append(bedrooms)
        except:
            pass
        
        # 2. –ò—â–µ–º –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞—Ö –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
        try:
            bed_selectors = [
                '[data-testid="bed-bath"]',
                '.property-details',
                '.TitleBlock_meta',
                '.BdRmBtListing',
                '[data-testid="beds"]'
            ]
            
            for selector in bed_selectors:
                element = await page.query_selector(selector)
                if element:
                    text = await element.text_content()
                    if text:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ text –Ω–µ None
                        # –ò—â–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
                        patterns = [
                            r'(\d+)\s*bed',
                            r'(\d+)\s*bedroom',
                            r'(\d+)\s*br\b',
                            r'beds?\s*:\s*(\d+)',
                            r'(\d+)\s*-?\s*bed'
                        ]
                        
                        for pattern in patterns:
                            matches = re.findall(pattern, text.lower())
                            for match in matches:
                                bedrooms = int(match)
                                if 0 <= bedrooms <= 10:
                                    found_bedrooms.append(bedrooms)
        except:
            pass
        
        # 3. –ò—â–µ–º –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        try:
            title_element = await page.query_selector('h1')
            if title_element:
                title_text = await title_element.text_content()
                if title_text:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ title_text –Ω–µ None
                    patterns = [
                        r'(\d+)\s*bed',
                        r'(\d+)\s*bedroom',
                        r'studio'  # –û—Ç–¥–µ–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º studio
                    ]
                    
                    if 'studio' in title_text.lower():
                        found_bedrooms.append(0)
                    else:
                        for pattern in patterns[:2]:  # –¢–æ–ª—å–∫–æ bed/bedroom –ø–∞—Ç—Ç–µ—Ä–Ω—ã
                            matches = re.findall(pattern, title_text.lower())
                            for match in matches:
                                bedrooms = int(match)
                                if 0 <= bedrooms <= 10:
                                    found_bedrooms.append(bedrooms)
        except:
            pass
        
        # 4. –ü–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–Ω—Å - –∏—â–µ–º –≤ —Ç–µ–∫—Å—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–±–æ–ª–µ–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ)
        try:
            # –ò—â–µ–º —Ç–æ–ª—å–∫–æ —á–µ—Ç–∫–∏–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è
            bed_patterns = [
                r'(\d+)\s*bedroom\s*(?:house|apartment|flat)',
                r'(?:house|apartment|flat).*?(\d+)\s*bedroom',
                r'(\d+)\s*bed\s*(?:house|apartment|flat)',
            ]
            
            for pattern in bed_patterns:
                matches = re.findall(pattern, page_content.lower())
                for match in matches:
                    bedrooms = int(match)
                    if 0 <= bedrooms <= 10:
                        found_bedrooms.append(bedrooms)
        except:
            pass
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        if found_bedrooms:
            # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
            unique_bedrooms = list(set(found_bedrooms))
            
            # –ï—Å–ª–∏ –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ - –±–µ—Ä–µ–º –µ–≥–æ
            if len(unique_bedrooms) == 1:
                return unique_bedrooms[0]
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–∞–∑–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –±–µ—Ä–µ–º –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è
            from collections import Counter
            counter = Counter(found_bedrooms)
            most_common = counter.most_common(1)[0][0]
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∂–µ—Ç—Å—è –Ω–µ—Ä–∞–∑—É–º–Ω—ã–º,
            # –±–µ—Ä–µ–º –Ω–∞–∏–º–µ–Ω—å—à–µ–µ —Ä–∞–∑—É–º–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            if most_common > 6:  # –û—á–µ–Ω—å –º–Ω–æ–≥–æ —Å–ø–∞–ª–µ–Ω
                reasonable_values = [b for b in unique_bedrooms if 1 <= b <= 6]
                if reasonable_values:
                    return min(reasonable_values)
            
            return most_common
        
        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º None
        return None
    
    def _extract_property_type(self, page_content: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏"""
        try:
            type_match = re.search(r'"propertyType":\s*"([^"]*)"', page_content)
            if type_match:
                return type_match.group(1)
        except:
            pass
        return None
    
    def _extract_description(self, page_content: str, max_length: int = 200) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        try:
            desc_match = re.search(r'"description":\s*"([^"]*)"', page_content)
            if desc_match:
                description = desc_match.group(1)
                return description[:max_length] + "..." if len(description) > max_length else description
        except:
            pass
        return None
    
    def _extract_location_from_title(self, title: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –ª–æ–∫–∞—Ü–∏—é –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞"""
        try:
            location_match = re.search(r'Dublin\s+\d+|Dublin\s+\w+', title)
            if location_match:
                return location_match.group()
        except:
            pass
        return None
    
    def _print_property_summary(self, prop: Dict[str, Any]):
        """–í—ã–≤–æ–¥–∏—Ç –∫—Ä–∞—Ç–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–±—ä—è–≤–ª–µ–Ω–∏–∏"""
        title = prop.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')[:50]
        price = f"‚Ç¨{prop['price']}" if prop.get('price') else '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞'
        beds = f"{prop['bedrooms']} —Å–ø–∞–ª–µ–Ω" if prop.get('bedrooms') else '–°–ø–∞–ª—å–Ω–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã'
        print(f"    ‚úÖ {title} - {price}, {beds}")
    
    def format_results(self, results: List[Dict[str, Any]], show_details: bool = True) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –≤—ã–≤–æ–¥–∞"""
        if not results:
            return "‚ùå –û–±—ä—è–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"
        
        output = [f"üè† –ù–ê–ô–î–ï–ù–û {len(results)} –û–ë–™–Ø–í–õ–ï–ù–ò–ô:\n"]
        
        for i, prop in enumerate(results, 1):
            price_str = f"‚Ç¨{prop['price']}" if prop['price'] else "–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞"
            bedrooms_str = f"{prop['bedrooms']} —Å–ø–∞–ª–µ–Ω" if prop['bedrooms'] else "–°–ø–∞–ª—å–Ω–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã"
            type_str = prop.get('property_type', '–¢–∏–ø –Ω–µ —É–∫–∞–∑–∞–Ω')
            location_str = prop.get('location', '–õ–æ–∫–∞—Ü–∏—è –Ω–µ —É–∫–∞–∑–∞–Ω–∞')
            
            output.append(f"{i}. {prop['title']}")
            output.append(f"   üí∞ {price_str} | üõèÔ∏è {bedrooms_str} | üè† {type_str}")
            output.append(f"   üìç {location_str}")
            
            if show_details:
                output.append(f"   üîó {prop['url']}")
            
            output.append("")
        
        return "\n".join(output)
    
    def get_statistics(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º"""
        if not results:
            return {}
        
        valid_prices = [r['price'] for r in results if r['price']]
        valid_bedrooms = [r['bedrooms'] for r in results if r['bedrooms']]
        
        stats = {
            'total_count': len(results),
            'with_price': len(valid_prices),
            'with_bedrooms': len(valid_bedrooms)
        }
        
        if valid_prices:
            stats.update({
                'avg_price': sum(valid_prices) / len(valid_prices),
                'min_price': min(valid_prices),
                'max_price': max(valid_prices)
            })
        
        if valid_bedrooms:
            stats.update({
                'avg_bedrooms': sum(valid_bedrooms) / len(valid_bedrooms),
                'min_bedrooms': min(valid_bedrooms),
                'max_bedrooms': max(valid_bedrooms)
            })
        
        return stats

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏"""
    print("üöÄ DAFT.IE PRODUCTION PARSER")
    print("=" * 50)
    
    parser = ProductionDaftParser()
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞
    search_params = {
        'min_bedrooms': 3,
        'max_price': 2500,
        'location': 'dublin-city',  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ª–æ–∫–∞—Ü–∏—é
        'limit': 20
    }
    
    print("üéØ –ü–ê–†–ê–ú–ï–¢–†–´ –ü–û–ò–°–ö–ê:")
    for key, value in search_params.items():
        print(f"   {key}: {value}")
    print()
    
    # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
    start_time = datetime.datetime.now()
    results = await parser.search_properties(**search_params)
    duration = (datetime.datetime.now() - start_time).total_seconds()
    
    # –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    print("\n" + "=" * 50)
    print("üìã –†–ï–ó–£–õ–¨–¢–ê–¢–´")
    print("=" * 50)
    
    formatted_output = parser.format_results(results, show_details=False)
    print(formatted_output)
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    stats = parser.get_statistics(results)
    print("=" * 50)
    print("üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê")
    print("=" * 50)
    print(f"‚è±Ô∏è  –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {duration:.1f} —Å–µ–∫—É–Ω–¥")
    print(f"üìä –ù–∞–π–¥–µ–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {stats.get('total_count', 0)}")
    
    if stats.get('avg_price'):
        print(f"üí∞ –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞: ‚Ç¨{stats['avg_price']:.0f}")
        print(f"üí∞ –î–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω: ‚Ç¨{stats['min_price']} - ‚Ç¨{stats['max_price']}")
    
    if stats.get('avg_bedrooms'):
        print(f"üõèÔ∏è  –°—Ä–µ–¥–Ω–µ–µ –∫–æ–ª-–≤–æ —Å–ø–∞–ª–µ–Ω: {stats['avg_bedrooms']:.1f}")
        print(f"üõèÔ∏è  –î–∏–∞–ø–∞–∑–æ–Ω —Å–ø–∞–ª–µ–Ω: {stats['min_bedrooms']} - {stats['max_bedrooms']}")
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    filename = f'daft_production_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump({
            'search_params': search_params,
            'results': results,
            'statistics': stats,
            'timestamp': datetime.datetime.now().isoformat()
        }, f, ensure_ascii=False, indent=2)
    
    print(f"üíæ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {filename}")

if __name__ == "__main__":
    asyncio.run(main())
