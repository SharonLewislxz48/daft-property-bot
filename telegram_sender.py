#!/usr/bin/env python3
"""
–ü—Ä–æ—Å—Ç–æ–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–∞—Ä—Å–µ—Ä–∞ –≤ Telegram
–ß–∏—Ç–∞–µ—Ç JSON —Ñ–∞–π–ª—ã —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏—è –≤ —á–∞—Ç
"""

import asyncio
import json
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any

import aiohttp
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class TelegramSender:
    """–û—Ç–ø—Ä–∞–≤—â–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram"""
    
    def __init__(self):
        self.bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.chat_id = os.getenv('CHAT_ID')
        
        if not self.bot_token or not self.chat_id:
            raise ValueError("–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å TELEGRAM_BOT_TOKEN –∏ CHAT_ID –≤ .env —Ñ–∞–π–ª–µ")
        
        self.api_url = f"https://api.telegram.org/bot{self.bot_token}"
        self.sent_properties_file = "sent_properties.json"
        self.sent_properties = self._load_sent_properties()
    
    def _load_sent_properties(self) -> set:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π"""
        try:
            if os.path.exists(self.sent_properties_file):
                with open(self.sent_properties_file, 'r') as f:
                    return set(json.load(f))
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {e}")
        return set()
    
    def _save_sent_properties(self):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–ø–∏—Å–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π"""
        try:
            with open(self.sent_properties_file, 'w') as f:
                json.dump(list(self.sent_properties), f)
        except Exception as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {e}")
    
    async def send_message(self, text: str) -> bool:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram"""
        try:
            async with aiohttp.ClientSession() as session:
                data = {
                    'chat_id': self.chat_id,
                    'text': text,
                    'parse_mode': 'HTML',
                    'disable_web_page_preview': False
                }
                
                async with session.post(f"{self.api_url}/sendMessage", data=data) as response:
                    if response.status == 200:
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {response.status} - {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            return False
    
    def format_property_message(self, prop: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram"""
        title = prop.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        price = f"‚Ç¨{prop['price']}" if prop.get('price') else '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞'
        bedrooms = prop.get('bedrooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
        location = prop.get('location', '–õ–æ–∫–∞—Ü–∏—è –Ω–µ —É–∫–∞–∑–∞–Ω–∞')
        url = prop.get('url', '')
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–ø–∞–ª—å–Ω–∏
        if bedrooms == 0:
            bed_text = "Studio"
        elif bedrooms == 1:
            bed_text = "1 —Å–ø–∞–ª—å–Ω—è"
        elif bedrooms in [2, 3, 4]:
            bed_text = f"{bedrooms} —Å–ø–∞–ª—å–Ω–∏"
        else:
            bed_text = f"{bedrooms} —Å–ø–∞–ª–µ–Ω"
        
        message = f"""üè† <b>{title}</b>

üí∞ <b>–¶–µ–Ω–∞:</b> {price}
üõèÔ∏è <b>–°–ø–∞–ª—å–Ω–∏:</b> {bed_text}
üìç <b>–†–∞–π–æ–Ω:</b> {location}

üîó <a href="{url}">–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ Daft.ie</a>"""
        
        return message
    
    async def send_properties(self, properties: List[Dict[str, Any]]) -> int:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –≤ Telegram"""
        sent_count = 0
        
        for prop in properties:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º URL –∫–∞–∫ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä
            property_id = prop.get('url', '')
            
            if not property_id:
                logger.warning("–û–±—ä—è–≤–ª–µ–Ω–∏–µ –±–µ–∑ URL, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
                continue
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –ª–∏ —É–∂–µ —ç—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
            if property_id in self.sent_properties:
                logger.debug(f"–û–±—ä—è–≤–ª–µ–Ω–∏–µ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {property_id}")
                continue
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            message = self.format_property_message(prop)
            
            if await self.send_message(message):
                self.sent_properties.add(property_id)
                sent_count += 1
                logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {prop.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')[:50]}")
                
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                await asyncio.sleep(2)
            else:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: {prop.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')[:50]}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π
        self._save_sent_properties()
        
        return sent_count

class PropertySender:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–π"""
    
    def __init__(self):
        self.telegram = TelegramSender()
        self.results_dir = Path("results")
    
    def find_latest_results_file(self) -> Path:
        """–ù–∞—Ö–æ–¥–∏—Ç —Å–∞–º—ã–π —Å–≤–µ–∂–∏–π —Ñ–∞–π–ª —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏"""
        json_files = list(self.results_dir.glob("daft_results_*.json"))
        
        if not json_files:
            raise FileNotFoundError("–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –≤ –ø–∞–ø–∫–µ results/")
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
        latest_file = max(json_files, key=lambda f: f.stat().st_mtime)
        logger.info(f"–ù–∞–π–¥–µ–Ω —Ñ–∞–π–ª —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏: {latest_file}")
        
        return latest_file
    
    def load_properties_from_file(self, file_path: Path) -> List[Dict[str, Any]]:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–∑ JSON —Ñ–∞–π–ª–∞"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # –§–∞–π–ª –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–±—ä–µ–∫—Ç—ã —Ä–∞–∑–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
            if isinstance(data, list):
                # –ü—Ä—è–º–æ–π —Å–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π
                return data
            elif isinstance(data, dict) and 'results' in data:
                # –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
                return data['results']
            else:
                logger.error("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞")
                return []
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {file_path}: {e}")
            return []
    
    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏"""
        try:
            logger.info("üöÄ –ó–∞–ø—É—Å–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–π –≤ Telegram")
            
            # –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–π–ª —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
            results_file = self.find_latest_results_file()
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏—è
            properties = self.load_properties_from_file(results_file)
            logger.info(f"üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(properties)} –æ–±—ä—è–≤–ª–µ–Ω–∏–π")
            
            if not properties:
                logger.warning("–ù–µ—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
                return
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏—è
            sent_count = await self.telegram.send_properties(properties)
            
            logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {sent_count} –Ω–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–≤–æ–¥–∫—É
            summary_message = f"""üìä <b>–°–≤–æ–¥–∫–∞ –ø–æ –ø–æ–∏—Å–∫—É</b>

üîç –ù–∞–π–¥–µ–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {len(properties)}
üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–æ–≤—ã—Ö: {sent_count}
‚è∞ –í—Ä–µ–º—è: {datetime.now().strftime('%d.%m.%Y %H:%M')}"""
            
            await self.telegram.send_message(summary_message)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏: {e}")
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            error_message = f"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–π</b>\n\n{str(e)}"
            try:
                await self.telegram.send_message(error_message)
            except:
                pass

async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    sender = PropertySender()
    await sender.run()

if __name__ == "__main__":
    asyncio.run(main())
